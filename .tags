!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AckRumor	types.go	/^type AckRumor struct{$/;"	d
AckRumor	types.go	/^type AckRumor struct{$/;"	t
AckRumorSlice	types.go	/^type AckRumorSlice []*AckRumor$/;"	d
AckRumorSlice	types.go	/^type AckRumorSlice []*AckRumor$/;"	t
BroadcastPacket	comm.go	/^func BroadcastPacket(pack *GossipPacket,con *net.UDPConn,addrList []*net.UDPAddr){$/;"	d
BroadcastPacket	comm.go	/^func BroadcastPacket(pack *GossipPacket,con *net.UDPConn,addrList []*net.UDPAddr){$/;"	f
BroadcastPacket	comm/main.go	/^func BroadcastPacket(pack *types.GossipPacket,con *net.UDPConn,addrList []*net.UDPAddr){$/;"	d
BroadcastPacket	comm/main.go	/^func BroadcastPacket(pack *types.GossipPacket,con *net.UDPConn,addrList []*net.UDPAddr){$/;"	f
GossipPacket	types.go	/^type GossipPacket struct{$/;"	d
GossipPacket	types.go	/^type GossipPacket struct{$/;"	t
GossipPacket	types/main.go	/^type GossipPacket struct{$/;"	d
GossipPacket	types/main.go	/^type GossipPacket struct{$/;"	t
Gossiper	types.go	/^type Gossiper struct{$/;"	d
Gossiper	types.go	/^type Gossiper struct{$/;"	t
Len	typesutil.go	/^func (s AckRumorSlice) Len() int{$/;"	d
Len	typesutil.go	/^func (s AckRumorSlice) Len() int{$/;"	f
Less	typesutil.go	/^func (s AckRumorSlice) Less(i, j int) bool{$/;"	d
Less	typesutil.go	/^func (s AckRumorSlice) Less(i, j int) bool{$/;"	f
Message	client/main.go	/^type Message struct{$/;"	d
Message	client/main.go	/^type Message struct{$/;"	t
Message	types.go	/^type Message struct{$/;"	d
Message	types.go	/^type Message struct{$/;"	t
NewGossiper	gossiper.go	/^func NewGossiper(uiport *string,gossipaddr *string,name *string,peers *string,simple bool, aetimeout uint,wg *sync.WaitGroup) (*Gossiper,error){$/;"	d
NewGossiper	gossiper.go	/^func NewGossiper(uiport *string,gossipaddr *string,name *string,peers *string,simple bool, aetimeout uint,wg *sync.WaitGroup) (*Gossiper,error){$/;"	f
PeerStatus	types.go	/^type PeerStatus struct {$/;"	d
PeerStatus	types.go	/^type PeerStatus struct {$/;"	t
ReadMessage	comm/main.go	/^func ReadMessage(con *net.UDPConn) (int, []byte, *net.UDPAddr, error){$/;"	d
ReadMessage	comm/main.go	/^func ReadMessage(con *net.UDPConn) (int, []byte, *net.UDPAddr, error){$/;"	f
ReadMessageClient	comm.go	/^func ReadMessageClient(con *net.UDPConn) (*Message, *net.UDPAddr, error){$/;"	d
ReadMessageClient	comm.go	/^func ReadMessageClient(con *net.UDPConn) (*Message, *net.UDPAddr, error){$/;"	f
ReadPacket	comm.go	/^func ReadPacket(con *net.UDPConn) (*GossipPacket, *net.UDPAddr, error){$/;"	d
ReadPacket	comm.go	/^func ReadPacket(con *net.UDPConn) (*GossipPacket, *net.UDPAddr, error){$/;"	f
ReadPacket	comm/main.go	/^func ReadPacket(con *net.UDPConn) (*types.GossipPacket, *net.UDPAddr, error){$/;"	d
ReadPacket	comm/main.go	/^func ReadPacket(con *net.UDPConn) (*types.GossipPacket, *net.UDPAddr, error){$/;"	f
RumorMessage	types.go	/^type RumorMessage struct{$/;"	d
RumorMessage	types.go	/^type RumorMessage struct{$/;"	t
RumorMessage	types/main.go	/^type RumorMessage struct{$/;"	d
RumorMessage	types/main.go	/^type RumorMessage struct{$/;"	t
SendMessage	comm.go	/^func SendMessage(message []byte,con *net.UDPConn,addr *net.UDPAddr){$/;"	d
SendMessage	comm.go	/^func SendMessage(message []byte,con *net.UDPConn,addr *net.UDPAddr){$/;"	f
SendMessage	comm/main.go	/^func SendMessage(message []byte,con *net.UDPConn,addr *net.UDPAddr){$/;"	d
SendMessage	comm/main.go	/^func SendMessage(message []byte,con *net.UDPConn,addr *net.UDPAddr){$/;"	f
SendMessageClient	client/main.go	/^func SendMessageClient(message *Message,con net.Conn){$/;"	d
SendMessageClient	client/main.go	/^func SendMessageClient(message *Message,con net.Conn){$/;"	f
SendMessageClient	comm/main.go	/^func SendMessageClient(message []byte,con net.Conn){$/;"	d
SendMessageClient	comm/main.go	/^func SendMessageClient(message []byte,con net.Conn){$/;"	f
SendPacket	comm.go	/^func SendPacket(pack *GossipPacket,con *net.UDPConn,addr *net.UDPAddr){$/;"	d
SendPacket	comm.go	/^func SendPacket(pack *GossipPacket,con *net.UDPConn,addr *net.UDPAddr){$/;"	f
SendPacket	comm/main.go	/^func SendPacket(pack *types.GossipPacket,con *net.UDPConn,addr *net.UDPAddr){$/;"	d
SendPacket	comm/main.go	/^func SendPacket(pack *types.GossipPacket,con *net.UDPConn,addr *net.UDPAddr){$/;"	f
SimpleMessage	types.go	/^type SimpleMessage struct {$/;"	d
SimpleMessage	types.go	/^type SimpleMessage struct {$/;"	t
SimpleMessage	types/main.go	/^type SimpleMessage struct {$/;"	d
SimpleMessage	types/main.go	/^type SimpleMessage struct {$/;"	t
StatusPacket	types.go	/^type StatusPacket struct{$/;"	d
StatusPacket	types.go	/^type StatusPacket struct{$/;"	t
StatusPacket	types/main.go	/^type StatusPacket struct {$/;"	d
StatusPacket	types/main.go	/^type StatusPacket struct {$/;"	t
Swap	typesutil.go	/^func (s AckRumorSlice) Swap(i, j int){$/;"	d
Swap	typesutil.go	/^func (s AckRumorSlice) Swap(i, j int){$/;"	f
addRumorClient	gossiperutil.go	/^func (g *Gossiper) addRumorClient(rumor *RumorMessage) (bool){$/;"	d
addRumorClient	gossiperutil.go	/^func (g *Gossiper) addRumorClient(rumor *RumorMessage) (bool){$/;"	f
addRumorPeer	gossiperutil.go	/^func (g *Gossiper) addRumorPeer(rumor *RumorMessage) (bool){$/;"	d
addRumorPeer	gossiperutil.go	/^func (g *Gossiper) addRumorPeer(rumor *RumorMessage) (bool){$/;"	f
addr	gossiperutil.go	/^	var addr *net.UDPAddr$/;"	d
antientropy	main.go	/^	var antientropy=flag.Uint("antiEntropy",10,$/;"	d
comm	comm/main.go	/^package comm$/;"	p
getRumorMessageHandler	webhandler.go	/^func (g *Gossiper) getRumorMessageHandler(w http.ResponseWriter, r *http.Request){$/;"	d
getRumorMessageHandler	webhandler.go	/^func (g *Gossiper) getRumorMessageHandler(w http.ResponseWriter, r *http.Request){$/;"	f
gossipaddr	main.go	/^	var gossipaddr=flag.String("gossipAddr","127.0.0.1:5000","ip:port for the gossiper (default \\"127.0.0.1:5000\\")")$/;"	d
gossiper	gossiper.go	/^	var gossiper Gossiper$/;"	d
main	client/main.go	/^func main() {$/;"	d
main	client/main.go	/^func main() {$/;"	f
main	client/main.go	/^package main$/;"	p
main	comm.go	/^package main$/;"	p
main	gossiper.go	/^package main$/;"	p
main	gossipercomm.go	/^package main$/;"	p
main	gossiperutil.go	/^package main$/;"	p
main	main.go	/^func main() {$/;"	d
main	main.go	/^func main() {$/;"	f
main	main.go	/^package main$/;"	p
main	thread.go	/^package main$/;"	p
main	types.go	/^package main$/;"	p
main	typesutil.go	/^package main$/;"	p
main	webhandler.go	/^package main$/;"	p
msg	client/main.go	/^	var msg=flag.String("msg","","message to be sent")$/;"	d
name	main.go	/^	var name=flag.String("name","defaultname","name of the gossiper")$/;"	d
peers	main.go	/^	var peers=flag.String("peers","127.0.0.1:5000","comma separated list of peers of the form ip:port")$/;"	d
peerstrslice	gossiper.go	/^	var peerstrslice []string$/;"	d
randomPeer	gossiperutil.go	/^func (g *Gossiper) randomPeer(indexNot int)(int , *net.UDPAddr){$/;"	d
randomPeer	gossiperutil.go	/^func (g *Gossiper) randomPeer(indexNot int)(int , *net.UDPAddr){$/;"	f
readMessage	comm.go	/^func readMessage(con *net.UDPConn) (int, []byte, *net.UDPAddr, error){$/;"	d
readMessage	comm.go	/^func readMessage(con *net.UDPConn) (int, []byte, *net.UDPAddr, error){$/;"	f
sendRumorMonger	gossipercomm.go	/^func (g *Gossiper) sendRumorMonger(rumor *RumorMessage,indexNot int,addrudp *net.UDPAddr){$/;"	d
sendRumorMonger	gossipercomm.go	/^func (g *Gossiper) sendRumorMonger(rumor *RumorMessage,indexNot int,addrudp *net.UDPAddr){$/;"	f
sendStatPacket	gossipercomm.go	/^func (g *Gossiper) sendStatPacket(addrudp *net.UDPAddr){$/;"	d
sendStatPacket	gossipercomm.go	/^func (g *Gossiper) sendStatPacket(addrudp *net.UDPAddr){$/;"	f
simple	main.go	/^	var simple=flag.Bool("simple",false,"run gossiper in simple broadcast mode")$/;"	d
threadGossip	thread.go	/^func (g *Gossiper) threadGossip(wg *sync.WaitGroup){$/;"	d
threadGossip	thread.go	/^func (g *Gossiper) threadGossip(wg *sync.WaitGroup){$/;"	f
threadUIcomplet	thread.go	/^func (g *Gossiper) threadUIcomplet(wg *sync.WaitGroup){$/;"	d
threadUIcomplet	thread.go	/^func (g *Gossiper) threadUIcomplet(wg *sync.WaitGroup){$/;"	f
threadUIsimple	thread.go	/^func (g *Gossiper) threadUIsimple(wg *sync.WaitGroup){$/;"	d
threadUIsimple	thread.go	/^func (g *Gossiper) threadUIsimple(wg *sync.WaitGroup){$/;"	f
threadUIweb	thread.go	/^func (g *Gossiper) threadUIweb(){$/;"	d
threadUIweb	thread.go	/^func (g *Gossiper) threadUIweb(){$/;"	f
types	types/main.go	/^package types$/;"	p
udpaddrequal	typesutil.go	/^func udpaddrequal(a1,a2 *net.UDPAddr) bool{$/;"	d
udpaddrequal	typesutil.go	/^func udpaddrequal(a1,a2 *net.UDPAddr) bool{$/;"	f
uiport	client/main.go	/^	var uiport=flag.String("UIPort","8080","port for the UI client (default \\"8080\\")")$/;"	d
uiport	main.go	/^	var uiport=flag.String("UIPort","8080","port for the UI client (default \\"8080\\")")$/;"	d
wg	main.go	/^	var wg sync.WaitGroup$/;"	d
